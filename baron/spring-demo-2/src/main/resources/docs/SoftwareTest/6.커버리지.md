1. ### 커버리지 (coverage)

   - 테스트 케이스를 준비하는 관점의 일종

   - 화이트 박스 테스트의 사고방식에 의거하고 있다.

     > **블랙 박스 테스트** : 소프트웨어 코드 내부의 로직을 고려하지 않고 외부에서 보았을 때의 움직이는 사양으로 케이스를 작성한다.
     >
     > **화이트 박스 테스트** : 코드 내부의 로직을 고려해서, 테스트 케이스를 작성한다. 이 테스트는 블랙 박스 테스트와는 다르게 프로그래밍 지식도 필요하다.

2. ### 데이터 플로우 테스트

   - 변수마다 생성 → 사용 → 폐기의 사이클을 확인하는 테스트
   - 변수를 생성하기도 전에 사용해버린다든지 하는 실수를 검출하는 테스트지만, 최근의 IDE에서는 자동적으로 검출해주기 때문에 최근에는 굳이 하지않는 테스트

3. ### 제어 플로우 테스트

   - 코드 처리가 어느정도 실행되었는가를 기준으로 테스트

   - 테스트 기법 [경계값 테스트]가 필요할 수 있다.

     ```java
     if (a < 0) {
     	print("excute")
     }
     ```

     경계값 관점에서는 0, -1이 케이스에 해당 하지만, 제어플로우 테스트에서는 해당 실행이 한번 통과 되는지 확인하면 되므로 -1만 있어도 충분하다는 점에서 관점이 다르다.

4. ### 커버리지

   - 테스트 가능한 코드 중 실제로 테스트 된 코드의 비율
   - 실행가능한 100행의 코드 중 80행이 실제로 테스트 되었다면 커버리지는 80%
   - 일반적으로는 실행된 행 수 / 실행가능한 행 수를 가리키지만...

5. ### 커버리지의 종류

   1. ##### 스테이트먼트 커버리지(statement coverage : 命令網羅)

      - 테스트의 망라성으로는 가장 수준이 낮음
      - C0 이라고도 표기한다. (커버리지 레벨 표기방법)
      - 실행한 행 수 / 실행 가능한 행 수 x 100
      - 공백, 주석, 중괄호 등은 행 수 계산에 포함시키지 않는다

   2. ##### 디시전 커버리지(decision coverage : 判定網羅)

      - 판정의 분기를 어느정도 망라했는가

      - C1 이라고도 표기한다. (커버리지 레벨 표기방법)

      - 실현한 판정 결과 수 / 모든 판정의 판정 결과의 합계 수 x 100

        ```java
        if (a > 0) {
        	x = 1
        }
        if (b == 2) {
        	y = 2
        }
        ```

        - 판정 [a > 0, b == 2] 즉 true와 false를 모두 확인하는 것을 가리킴
        - a = 1 / b = 2 인 경우 → 디시전 커버리지 50%
        - a = 1, 0 / b = 2, 1 인 경우 → 디시전 커버리지 100%

        ```java
        if (a > 0 && c == 1) {
        	print("ac")
        }
        if (b == 2 || d < 0) {
        	print("bd")
        }
        ```

        - [ a > 0 ] && [ c == 0 ] 과 같은 복합조건인 경우에도 총 조건의 true, false만 확인하면 되므로 

          [a = 1, c = 1, b = 2, d = -1] 와 [a = 0, c = 0, b = 1, d = 2]으로도 커버리지 100%를 만족한다.

   3. ##### 컨디션 커버리지

      - 판정 속 조건식의 진위를 어느정도 망라했는가

      - C2로도 표기

      - 실현된 조건식의 결과 수 / 모든 조건식의 결과 합계 수 x 100

        ```java
        if (a > 0 && c == 1) {
        	x = 1;
        }
        if (b == 2 || d < 0) {
        	y = 2;
        }
        ```

        - 2개의 판정 속 4개의 조건식이 있고, 각 조건에 true와 false가 있으므로, 위에서 모든 조건식의 결과 합계 수는 8이다.
        - 각각의 false와 true만 확인하면 되므로 [a = 1, c = 1, b = 2, d = -1] 와 [a = 0, c = 0, b = 1, d = 2] 2케이스로도 커버리지 100%를 만족한다.
        - 컨디션 커버리지(**C2**)가 100%를 만족하더라도, 스테이트먼트 커버리지(**C0**)와 디시젼 커버리지(**C1**)를 모두 만족한다는 보장이 없다.

   4. ##### 복합 컨디션 커버리지 (multiple condition coverage : MCC) 

      - 조건식 진위의 조합을 어느정도 망라했는가

      - MCC로도 표기

      - 실현된 조건식의 진위 조합 수 / 조건식의 진위 조합 합계 수 x 100

      - 망라성은 높지만 테스트 케이스가 필요이상으로 많아 실제로는 **MD/DC 커버리지**를 더 많이 사용한다.

        ```java
        if (a > 0 && c == 1) {
        	x = 1;
        }
        if (b == 2 || d < 0) {
        	y = 2;
        }
        ```

        | 조건식 | case 1 | case 2 | case 3 | case 4 |
        | ------ | ------ | ------ | ------ | ------ |
        | a > 0  | true   | true   | false  | false  |
        | c == 1 | true   | false  | true   | false  |

        | 조건식 | case 1 | case 2 | case 3 | case 4 |
        | ------ | ------ | ------ | ------ | ------ |
        | b == 2 | true   | true   | false  | false  |
        | d < 0  | true   | false  | true   | false  |

   5. ##### MC/DC 커버리지 (modified condition / decision coverage)

      - 복합 컨디션 커버리지를 개량해 필요한 테스트 케이스를 삭감한 커버리지 레벨

      - 조건식의 진위 조합을 망라하는 것이 아니라 디시젼 커버리지(**C1**) 100%와 컨디션 커버리지(**C2**) 100%를 달성하는 커버리지 레벨

        ```java
        // AND든 OR든 하나의 판정만으로도 조건식의 결과를 좌우할 수 있다는 것에 주목
        if (a > 0 && c == 1) {
            // 용어 정립
            // - 조건식 : (a > 0) , (c == 1)
            // - 판정 : (a > 0 && c == 1)
        	x = 1;
        }
        if (b == 2 || d < 0) {
        	y = 2;
        }
        ```

      - AND라면 하나의 판정이라도 false가 있다면 전체가 false가 되고

      - OR라면 하나의 판정이라도 true가 있다면 전체가 true가 되는 특징을 고려

      - 기본적으로 [**조건식의 수 + 1**]의 수 만큼 테스트 케이스를 준비하면 된다.

        |        | 1    | 2    | 3    |
        | ------ | ---- | ---- | ---- |
        | a > 0  | 참   | 참   | 거짓 |
        | c == 1 | 참   | 거짓 | 참   |

      - 자동차/항공기/은행 시스템 등 버그 발생이 용서되지않는 시스템에 사용된다.

#### 6. 커버리지의 특징

> 1. ###### 커버리지가 높다고해서 품질을 보증한다고 할 수 없다.
>
>    - 있어야할 코드가 없다었다
>    - 코딩구현의 실수
>
> 2. ##### 커버리지가 100%에 가까울 수록 버그 검출 비용 대비 효과가 떨어진다.
>
>    - 테스트 케이스가 증가할 수록 검출되는 버그는 많아진다.
>    - 테스트 케이스 작성에 따른 비용은 일정하게 증가하지만 버그 검출량은 체감한다,
>
> 3. ##### 커버리지의 수치가 테스트의 목적이 되어서는 안된다.
>
>    - 커버리지의 수치는 품질을 보증하기 위한 수단에 불과함
>    - 그렇다고해서 커버리지 100%가 품질을 보증하진 않음

7. #### 커버리지의 활용 포인트

   1. ##### 테스트 케이스는 커버리지가 아닌 테스트 기법을 근거로 작성한다.

      - 테스트 기법으로 테스트 케이스를 설계한다.
      - 테스트 케이스를 실행해본 뒤 커버리지를 계산해본다.
      - 커버리지가 너무 낮으면 핀 포인트 관점에서 테스트 케이스를 추가한다.

   2. ##### 100% 커버리지를 노리지 않고 85%정도의 커버리지를 달성하도록 노력하는 정도로 임한다.

      - 컴파일러가 버그를 발견하거나하는 경우가 있는데 이 경우 사람이 직접 테스트할 필요가 없다.
      - 크리티컬하지 않은 서비스인 경우 유저가 사용하면서 버그를 신고하는 것을 기대하는 것이 테스트 비용 절감으로 이어진다.



