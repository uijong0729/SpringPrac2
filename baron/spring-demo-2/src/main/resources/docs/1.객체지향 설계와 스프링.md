1. #### 자바 진영의 추운 겨울과 스프링의 탄생

   1. EJB (Enterprise Java Beans)의 지배
      1. 고비용 유료 모델
         - IBM : EJB + WebSphere
         - Oracle : EJB + WebLogic
      2. Entity Bean
         - ORM기술 대응
   2. EJB지옥
      - EJB의존적인 개발
   3. POJO
      - EJB 관두고 옛날로 돌아가자

   4. 스프링

      1. EJB 컨테이너 대체

      2. EJB없이도 고품질의 확장 가능한 애플리케이션을 개발할 수 있음

      3. 현재 사실상 표준 기술

      4. BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입

      5. 스프링 역사

         > 1. 스프링 프레임워크 1.0 : XML
         > 2. 스프링 프레임워크 2.0 : XML편의 기능 지원
         > 3. 스프링 프레임워크 3.0 : XML없이 자바 코드로 설정
         > 4. 스프링 프레임워크 4.0 : 자바8 지원
         > 5. 스프링부트 1.0 출시
         > 6. 스프링 프레임워크 5.0 : 리엑티브 프로그래밍 지원
         > 7. 스프링부트 2.0 : 리엑티브 프로그래밍 지원

   5. 하이버네이트

      1. EJB 엔티티빈 기술을 대체
      2. 하이버네이트 기반으로 JPA (Java Persistence API)라는 새로운 표준 정의

2. #### 스프링이란 (https://spring.io/projects)

   1. 필수

      1. 스프링 프레임워크
      2. 스프링 부트

   2. 선택

      1. 스프링 데이터
      2. 스프링 세션
      3. 스프링 시큐리티
      4. 스프링 Rest Docs
      5. 스프링 배치
      6. 스프링 클라우드

   3. 스프링 프레임워크

      1. 핵심기술 : 스프링 DI 컨테이너, AOP, 이벤트 등
      2. 웹 기술 : 스프링 MVC 등
      3. 데이터 접근 기술 : 트랜잭션, JDBC, ORM지원 등
      4. 기술 통합 : 캐시, 이메일, 원격접근 등
      5. 테스트
      6. 언어 : 코틀린, 그루비

   4. 스프링 부트

      1. 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
      2. 별도의 웹 서버 설치 불필요 (웹 서버 내장)
      3. 손쉬운 빌드구성 : starter 종속성 제공
      4. 스프링과 3rd parth 라이브러리 자동 구성 (외부 라이브러리의 버전 궁합과 조합을 조정)
      5. 운영환경을 위한 모니터링 기능 제공 (메트릭, 상태확인, 외부구성 같은 프로덕션 준비 기능)

      6. **스프링 부트는 스프링 프로젝트의 세팅을 돕는 프로젝트일 뿐 스프링 부트가 스프링과는 독립적인 프로젝트는 아니라는 것에 주의**

   5. 스프링은 문맥에 따라 다른 의미로 사용된다

      1. 스프링 **DI**컨테이너 기술
      2. 스프링 **프레임워크**
      3. 스프링부트, 스프링프레임워크 등을 모두 포함한 **스프링 생태계**

3. #### 스프링의 핵심

   - 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크

4. #### 좋은 객체지향 프로그래밍

   1. 객체지향 특징
      - 추상화
      
      - 캡슐화
      
      - 상속
      
      - **다형성** : Polymorphism
      
        > 그러나 다형성 만으로는 OCP, DIP를 지킬 수 없다.
   2. 객체지향 프로그래밍
      - 독립된 단위 객체들의 모임
      - 객체들은 메시지를 주고받고 데이터를 처리할 수 있다
      - 유연하고 변경이 용이

   3. 자바에서의 다형성

      - 오버라이딩 된 메서드가 실행

      - 다형성으로 인터페이스를 **구현한 객체를 실행 시점에 유연하게 변경**할 수 있다.

        > @확장 가능한 설계
        >
        > @클라이언트에 영향을 주지않는 변경
        >
        > @인터페이스를 안정적으로 잘 설계하는 것이 중요
        >
        > @인터페이스 자체가 변하면 클라이언트/서버 모두에 큰 변경이 발생

   4. 스프링과 객체지향
      - 제어의 역전 IoC
      - 의존관계 주입 DI
   5. **좋은 객체지향 설계의 5가지 원칙 (SOLID)**

      1. SRP (Single Responsibility Principle) 
         - 단일 책임 원칙
         - 한 클래스는 하나의 책임만 가져야 한다
         - **변경**이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것
      2. OCP (Open/Close Principle)
         - 개방-폐쇄 원칙
         - 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다
         - 다형성을 활용 : 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
      3. LSP (Liskov Substitution Principle)
         - 리스코프 치환 원칙

         - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.

         - 컴파일 단계를 넘어 인터페이스의 규약에 따라 기능적으로 보장해야한다.

           - 리스코프 치환원칙을 위반 예

             > move() -> 멈추는 기능
             >
             > stop() -> 움직이는 기능 
      4. ISP (Interface Segregation Principle)
         - 인터페이스 분리 원칙
         
         - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
         
           적당한 크기로 인터페이스를 쪼개는 것이 중요
         
         - 인터페이스가 명확해지고 대체 가능성이 높아진다.
      5. DIP (Dependency Inversion Principle)
         - 의존관계 역전 원칙
         - 프로그래머는 **추상화에 의존**하고, 구체화에 의존하면 안된다.
         - 사용자가 코드를 읽을 때 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 뜻
         - 역할에 의존 O , 구현에 의존 X

5. 스프링과 객체지향설계
   - 이상적으로는 모든 설계에 인터페이스를 부여
   - 실무적인 고민
     - 인터페이스를 남발하면 추상화라는 비용이 발생
     - 추상화로 인해 개발자가 코드를 한번 더 열어봐야함

