1. ### IT 시스템의 역사

   1. 60~80년대 : Fragile, Cowboys : 깨지기 쉬운 시스템
   2. 80~00년대 : Robust, Distributed : 안정성이 있는 서비스를 
   3. 2010년~ : Anti-Fragile, Cloud Native : 확장성과 안정성 강화 
      - Wiki
      - DevOps
      - Cloud Native

2. ### Anti-fragile

   1. Auto scaling
      - 자동 확장성
      - 데이터의 사용량에 따라 자동적으로 인스턴스(서버)가 증가되는 환경
   2. Microservices
      - 복잡하게 얽혀져 있는 서비스 간의 구성
      - 넷플렉스, 아마존 등에서 가장 잘 구현됨
      - 기존의 시스템들은 하나의 거대한 형태로 구축되어 운영하였지만, 마이크로 서비스는 개별적인 모듈이나 기능을 독립적으로 개발하고 배포하여 운영할 수 있도록 세분화된 서비스이다.
   3. Chaos Engineering
      - 시스템의 변동
      - 예견된 불확실성
      - 예견되지않은 불확실성

   4. Continuous deployment
      - CI : Continuous Integration. 지속적 배포 
      - CD : Continuous Development. 지속적 개발
      - 일일히 개발하고 빌드하고 배포하는 작업은 시간과 비용이 많이 걸린다.

3. ### Cloud Native Architecture의 특징

   1. 확장 가능한 아키텍처
      - 시스템의 수평적 확장에 유연
      - 확장된 서버로 시스템 부하 분산 (가용성 보장)
      - 시스템 또는 서비스 애플리케이션 단위의 패키지 (컨테이너 기반 패키지)
      - 모니터링 도구를 이용해서 리소스의 사용을 확인

   2. 탄력적 아키텍처

      - 서비스 생성-통합-배포에 대응시간 단축

      - 비즈니스 환경변화에 대응시간 단축

      - 분리된 서비스 구조 (서비스간 종속성 최소화 해야한다)

      - 무상태 통신 프로토콜

        > 어떠한 이전 요청과도 무관한 각각의 요청을 독립적인 트랜잭션으로 취급하는 통신 프로토콜

      - 서비스의 추가와 삭제를 자동으로 감지

      - 변경된 서비스 요청에 따라 사용자 요청을 동적으로 처리

   3. 장애 격리 (Fault isolation)
      - 특정 서비스에 오류가 발생해도 다른 서비스에 영향을 주지 않음
      - 각각의 서비스는 **독립적인** 작은 애플리케이션이므로 장애 복구에 유리

4. ### 클라우드 네이티브 애플리케이션

   1. 마이크로 서비스로 개발

   2. CI/CD : 자동으로 통합되고 빌드, 배포의 과정을 거친다.

      - CI : 지속적 통합

        > 통합 서버, 소스 관리, 빌드 도구, 테스트 도구
        >
        > Jenkins, Team CI, Travis CI 등

      - CD : 지속적 배포

        > Continuous Delivery : 지속적인 전달 (전달 후 서버 반영은 수동 조작)
        >
        > Continuous Deployment : 지속적인 배포 (서버에의 전달과 반영 모두 자동화)
        >
        > Pipe line 등
        >
        > - 카나리 배포 : 95%의 사용자는 이전버전 서비스를, 5%의 사용자는 새 버전 서비스를 이용
        >
        > - 블루그린 배포 : 이전 버전 서비스에서 새 버전 서비스로 점진적인 이동

   3. DevOps : 마이크로 서비스에 문제가 발생할 경우, 문제를 수정해서 재배포

      1. 고객의 요구사항은 언제든지 변경될 수 있다. => 필요할 때 마다 바로바로 수정할 수 있는 구조
      2. 에러없는 완성물 => 자주 테스트하고, 자주 업데이트 하고, 자주 피드백을 거치는 과정을 지속적으로 진행해나가는 것

      > - Development 
      > - Opertaions 
      > - QA (Quality assurance) 

   4. Containers : 클라우드 환경에 배포하고 사용하기위한 가상화 기술

      1. 컨테이너 가상화 기술 : 적은 리소스를 사용하여 가상화 서비스 구축
      2. 전통적인 개발 : 하드웨어 + OS + 애플리케이션
      3. 가상화된 개발 : 하드웨어 + OS + 하이퍼바이저 + 가상머신[OS + 애플리케이션]
      4. **컨테이너 개발** : 하드웨어 + OS + 컨테이너 런타임 + 컨테이너[애플리케이션]
         - 더 적은 리소스
         - 가볍고 빠르게 작동한다.

5. ### [12 Factors] : 클라우드 네이티브  애플리케이션을 개발하거나 운영할 때 고려할 12가지

   1. Base code : 코드 통합
      - 버전을 제어하기 위한 목적
      - 코드를 한 곳에서 통일 관리
   2. Dependency isolation : 종속성 배제
      - 각 마이크로 서비스는 자체 종속성을 가지고 패키징되어있어 전체 시스템에 영향을 주지 않은 상태로 변경, 수정 될 수 있어야 한다.
   3. Configurations : 환경설정의 외부관리
      - 코드의 외부에서 구성 관리 도구를 통해 구성 작업
   4. Linkable backing services : 백업 서비스의 분리
   5. stages of creation : 개발환경과 테스트 운영환경의 분리
      - 빌드/릴리즈/실행환경을 각각 분리해야한다.
   6. stateless processes : 상태 관리 
      - 각각의 마이크로 서비스는 자체 프로세스에서 독립적으로 실행
   7. port binding : 포트 바인딩
   8. concurrency : 동시성
      - 하나의 서비스가 아닌 많은 수의 서비스를 복사해 확장해 나감
   9. disposablity : 서비스의 올바른 상태 유지
      - 서비스 인스턴스 : 등록 가능 / 삭제가능 / 확장가능 / 종료가능
   10. dvelopement & production parity : 개발단계와 프로덕션 단계의 구분
   11. logs : 로그의 분리
       - 각각의 마이크로 서비스에 의해서 생성된 로그를 이벤트 스트림으로 처리
       - Azure 모니터링 도구 등
   12. admin processes for eventual processes : 관리 프로세스
       - 현재 운영되고있는 모든 마이크로 서비스들이 어떤 상태로 사용되고 있는지 파악하는 도구
       - Report기능, 데이터 분석기능 포함

6. ### [12 Factors] + 3

   1. API First : API를 사용자 측이 어떻게 사용할지를 고민
   2. Telemetry : 모든 지표는 수치화되어 관리되어야 한다.
   3. Authentication and authorization : API 사용에 있어 적절한 인증을 가진 리소스들끼리 데이터 교환

7. ### 시스템을 구축하고 운영하는 방식

   1. ### Monolithic  (모놀리스)

      - 하나의 소프트웨어에 모든 서비스들을 포함시켜 개발

      - 각 서비스들은 서로 간에 의존성을 가진 채 패키징 되고, 운영서버에 배포한다.
      - 애플리케이션에서 사용하는 데이터가 한 곳에 모여 참조되어 서비스되는 형태
      - the shop team : 하나의 팀에서 모든 것을 개발 (shop은 예시)

   2. Front & Back

      - 프론트 엔드와 백 엔드를 구분해서 개발하는 방식
      - 모바일 어플리케이션에서 주로 적용
      - Frontend : Frontend Team
      - Backend : Backend & DevOps Team

   3. ### MSA (Microservice Architecture)

      - Small autonomous services that work together : 함께 작동하는 작은 규모의 서비스들

      - 유지보수, 변경사항 적용에 유리

      - 분리된 서비스가 다른 서비스에 영향을 주지 않거나 최소한의 영향만 주면서 배포한다.

      - HTTP API에 통신할 수 있는 작은 규모의 서비스들의 묶음

      - 서로 다른 프로그래밍 언어와 서로 다른 데이터 스토리지 기술을 사용할 수 있다.

      - Frontend : Frontend Team

      - Aggregation Layer : GraphQL 등 

      - Backend : Product Service, Reco Service, Basket Service, Payment Service 등 

        <img src="D:\code\spring\baron\spring-demo-2\src\main\resources\docs\Microservice\image-20210730231728677.png" align=left alt="image-20210730231728677" style="zoom: 50%;" />

